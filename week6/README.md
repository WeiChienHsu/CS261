# Hash Map (Dictionary)

a very specific type of search. Elements are placed into the dictionary in key/value pairs.

To do a retrieval, the user supplies a key, and the container returns the associated value. Each key identifies one entry; that is, each key is unique.

- get(key)
- put(key, value)
- containsKey(key)
- removeKey(key)
- keys()
- size

***

# Hashing Function

Almost any process that converts a value into an integer can be used as a hash function. 

So in O(1) time Amy can change a name into an integer index value, then use this value to index into a table. This is faster than an ordered data structure. 

What Amy has discovered is called a "perfect hash function".
(No collisions in whole cases which means the character chose to be the key is unique) 
Hash functions are only required to return a value that is integer, not necessarily positive. So it is common to surround the calculation with abs( ) to ensure a positive value.


- FAST (Constant time)
- Produce UNIOFRMLY distributed indices
- REPEATABLE



## Computing a Hash Table index 

### 1. Transform the value (or key) to an integer (using the hash function)

#### Mapping:
Map a part of the key into an integer.
- A letter to its position in the alphabet

#### Folding:
Key partitioned into parts which are then combined using efficient operations.
- Summing the values of each character in a string

#### Shifting:
Get rid of high or low order bits that are not random
- If keys are always even, shift off the low order bit

#### Casts:
Converting a numeric type into an integer
- Casting a character to an int to get its ASCII value.
- Data -> a value associated with current time
- Double -> a value generated by its bitwise representation
- Integer -> the int value itself
- String -> a folded sum of the character values
- URL -> the hash on the host name

### 2. Map that integer to a valid hash table index 

#### Use modulus operator % with table size
- idx = hash(val) % size

#### Use only postive arithmetic or take absolute value

#### To get a good distribution of indices, prime numbers make the best table size


***

# Collisions

## Open Address Hashing(Probing) - Deal with collisions

1. Construct a Bag.
2. Use the Bag as the source for a Dictionary.
3. When open-address hashing is used all elements are stored in a single large table.
4. Positions that are not yet filled are given a null value. 

| 0 - aiqy | 1 - bjrz | 2 - cks | 3 - dlt | 4 - emu | 5 - fnv | 6 - gow | 7 - hpx |
|:--------:|:--------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|
| amIna    |          |         | anDy    | alEssia | alFred  |         | asPen   |


If AnNe now joins the club, we will find that the hash value (namely, 5) is the same as for AlFred. 

So to find a location to store the value Anne we "probe" for the next free location.

- This means to simply move forward, position by position, "until an empty location is found".

| 0 - aiqy | 1 - bjrz | 2 - cks | 3 - dlt | 4 - emu | 5 - fnv | 6 - gow | 7 - hpx |
|:--------:|:--------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|
| amIna    |   AgNes  |         | anDy    | alEssia | alFred  |   AnNe  | asPen   |


AgNes wishes to join the club. Her hash value, 6, is already filled. The probe
moves forward to the next position, and when the end of the array is reached it continues with the first element.

Finally, suppose Alan(0) wishes to join the club.

| 0 - aiqy | 1 - bjrz | 2 - cks | 3 - dlt | 4 - emu | 5 - fnv | 6 - gow | 7 - hpx |
|:--------:|:--------:|:-------:|:-------:|:-------:|:-------:|:-------:|:-------:|
| amIna    |   AgNes  |AlAn     | anDy    | alEssia | alFred  |   AnNe  | asPen   |


## Load Factor

The ratio of the number of elements to the table size. For open address hashing the load factor is never larger than 1. 


a common solution to a full hash table is to "move all values into a new and larger table" when the load factor becomes larger than some threshold, such as 0.75. 

To do so a new table is created, and every entry in the old table is "rehashed", this time "dividing by the new table size to find the index to place into the new table".

Think about searching the table above for the value Alan, for example. Instead of immediately halting, an unsuccessful test must continue to probe, moving forward until either the value is found or an empty location is encountered.


***


## Caching

Indexing into a hash table is extremely fast, even faster than searching a skip list or an AVL tree. When a search request is received, the cache will examine the hash table. If the value is found in the cache, it is simply returned. If it is not found, then the original data structure is examined.


## Hash Table with Buckets - collisions

A hash table that uses buckets is really a combination of an array and a linked list. Each element in the array (the hash table) is a header for a linked list. All elements that hash into the same location will be stored in the list. For the Bag type abstraction the link stores only a value and a pointer to the next link. For a dictionary type abstraction, such as we will construct, the link stores the key, the value associated with the key, and the pointer to the next link.


Each operation on the hash table divides into two steps. First, the element is hashed and the remainder taken after dividing by the table size. This yields a table index. Next, linked list indicated by the table index is examined. The algorithms for the latter are very similar to those used in the linked list.

### Compare Probing and Chaining

As with open address hash tables, the load factor (λ) is defined as the number of elements divided by the table size. In this structure the load factor can be larger than one, and represents the average number of elements stored in each list, assuming that the hash function distributes elements uniformly over all positions. Since the running time of the contains test and removal is proportional to the length of the list, they are O(λ). Therefore the execution time for hash tables is fast only if the load factor remains small. A typical technique is to resize the table (doubling the size, as with the vector and the open address hash table) if the load factor becomes larger than 10.